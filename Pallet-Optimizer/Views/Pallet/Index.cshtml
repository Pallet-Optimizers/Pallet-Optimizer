@model Pallet_Optimizer.Models.PalletHolder
@{
    Layout = null;
}

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Pallet Visualizer</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        body { margin: 0; display:flex; height:100vh; font-family: Arial, sans-serif; }
        .sidebar { width:360px; background:#0b1220; color:#e6eef6; padding:12px; box-sizing:border-box; overflow:auto;}
        .content { flex:1; position:relative; }
        canvas { width:100%; height:100%; display:block; }
        input, select { width:100%; padding:6px; margin-bottom:8px; box-sizing:border-box; }
        button { padding:8px 12px; background:#2b9cff; color:white; border:none; cursor:pointer; }
        table { width:100%; color:#e6eef6; font-size:13px; border-collapse:collapse;}
        td, th { padding:6px; border-bottom:1px solid rgba(255,255,255,0.03);}
    </style>
</head>
<body>
    <div class="sidebar">
        <h3>Pallet Visualizer</h3>

        <div>
            <label>Element name</label>
            <input id="elName" />
            <label>Width (m)</label>
            <input id="elW" type="number" step="0.01" value="0.4" />
            <label>Depth (m)</label>
            <input id="elD" type="number" step="0.01" value="0.4" />
            <label>Height (m)</label>
            <input id="elH" type="number" step="0.01" value="0.3" />
            <label>Weight (kg)</label>
            <input id="elWeight" type="number" step="0.1" value="5" />
            <label><input id="elRotate" type="checkbox" checked /> Can rotate</label><br />
            <label><input id="elAlone" type="checkbox" /> Must be alone</label><br />
            <button id="addElement">Add element & repack</button>
        </div>

        <hr />
        <h4>Pallets</h4>
        <div id="palletList"></div>
    </div>

    <div class="content">
        <canvas id="renderCanvas"></canvas>
    </div>

    <script>
        const holder = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model ?? new Pallet_Optimizer.Models.PalletHolder()));
        let sceneState = { holder: holder };

        // Babylon init
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.07,0.11,0.14,1);
        const camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/3, 5, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);

        const light = new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);
        light.intensity = 0.8;

        let groupNodes = [];

        function clearScene() {
            groupNodes.forEach(n => n.dispose());
            groupNodes = [];
        }

        function renderHolder(h) {
            clearScene();
            let offsetX = 0;
            const gap = 0.6; // gap between pallets in meters

            (h.Pallets || []).forEach((p, i) => {
                const group = new BABYLON.TransformNode("palletGroup_" + i, scene);

                // pallet base
                const base = BABYLON.MeshBuilder.CreateBox("base_" + i, {
                    width: p.Width, height: 0.05, depth: p.Length
                }, scene);
                base.position = new BABYLON.Vector3(offsetX + p.Width/2, 0.025, p.Length/2);
                const mat = new BABYLON.StandardMaterial("mat_"+i, scene);
                mat.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
                base.material = mat;
                base.parent = group;

                // draw elements
                (p.Elements || []).forEach((el, idx) => {
                    const w = el.Rotated ? el.Depth : el.Width;
                    const d = el.Rotated ? el.Width : el.Depth;
                    const hgt = el.Height;
                    const box = BABYLON.MeshBuilder.CreateBox("el_"+i+"_"+idx, { width: w, height: hgt, depth: d }, scene);
                    box.position = new BABYLON.Vector3(offsetX + el.X + w/2, 0.05 + el.Z + hgt/2, el.Y + d/2);
                    const emat = new BABYLON.StandardMaterial("emat_"+i+"_"+idx, scene);
                    emat.diffuseColor = BABYLON.Color3.FromHSV((idx*47)%360, 0.6, 0.9);
                    box.material = emat;
                    box.parent = group;
                });

                groupNodes.push(group);
                offsetX += p.Width + gap;
            });

            // adjust camera radius
            const totalWidth = (h.Pallets || []).reduce((s,p)=>s+(p.Width||1.2)+gap, 0);
            camera.radius = Math.max(3, totalWidth);
        }

        engine.runRenderLoop(()=>scene.render());
        window.addEventListener('resize', ()=>engine.resize());

        // initial render
        renderHolder(sceneState.holder);
        rebuildPalletList();

        // UI functions
        function rebuildPalletList() {
            const el = document.getElementById('palletList');
            el.innerHTML = '';
            (sceneState.holder.Pallets || []).forEach(p => {
                const div = document.createElement('div');
                div.innerHTML = `<strong>${p.Name}</strong> (W:${p.Width} L:${p.Length} H:${p.MaxHeight}) - elements: ${p.Elements?.length || 0}`;
                el.appendChild(div);
            });
        }

        async function postJson(url, body) {
            const r = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
            if (!r.ok) throw new Error(await r.text());
            return r.json();
        }

        document.getElementById('addElement').addEventListener('click', async ()=> {
            const dto = {
                Name: document.getElementById('elName').value || 'Box',
                Width: parseFloat(document.getElementById('elW').value) || 0.4,
                Depth: parseFloat(document.getElementById('elD').value) || 0.4,
                Height: parseFloat(document.getElementById('elH').value) || 0.3,
                WeightKg: parseFloat(document.getElementById('elWeight').value) || 1,
                CanRotate: document.getElementById('elRotate').checked,
                MustBeAlone: document.getElementById('elAlone').checked
            };

            try {
                const json = await postJson('/Pallet/AddElement', dto);
                if (json && json.holder) {
                    sceneState.holder = json.holder;
                    renderHolder(sceneState.holder);
                    rebuildPalletList();
                } else {
                    alert('Add returned unexpected result');
                }
            } catch (err) {
                console.error(err);
                alert('Add failed: ' + err.message);
            }
        });
    </script>
</body>
</html>
